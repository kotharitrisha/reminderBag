/** * GAModelOptimizer.java * * The GAModelOptimizer class implements a genetic * algorithms approach to optimizing network partitions * * (c) 2000 Wibi Internet */ package com.wibinet.networks;import java.awt.*;import java.awt.event.*;import java.util.*;import javax.swing.*;import javax.swing.event.*;import com.wibinet.ai.core.*;import com.wibinet.ai.ga.*;public class GAModelOptimizer implements ModelOptimizer{ 	protected Hashtable props; 	 	// properties... 	protected final static String MAX_BLOCKS = "maxBlocks"; 	protected final static String MIN_PRECISION = "minPrecision"; 	protected final static String MAX_PRECISION = "maxPrecision"; 	protected final static String POP_SIZE = "populationSize"; 	protected final static String MUTATE_PROB = "mutateProbability"; 	protected final static String CLONE_PROB = "cloneProbability"; 	protected final static String SCORE_POWER = "scorePower"; 	 	public GAModelOptimizer() 	{ 	  props = new Hashtable(); 	  props.put(MAX_BLOCKS, new Integer(5)); 	  props.put(MIN_PRECISION, new Integer(1)); 	  props.put(MAX_PRECISION, new Integer(8)); 	  props.put(POP_SIZE, new Integer(64)); 	  props.put(MUTATE_PROB, new Double(0.10)); 	  props.put(CLONE_PROB, new Double(0.10)); 	  props.put(SCORE_POWER, new Double(1.0)); 	} 	 	public Blockmodel optimize(NetworkData nData, ModelMeasure measure, 		BlockmodelFactory mFactory) 	{ 		// get max blocks from properties 		int maxBlocks = nData.getSize();  	ModelGAProblem gaProblem = new ModelGAProblem(nData, measure, mFactory);  	TerminatorDialog terminator = new TerminatorDialog(null,   	  "Genetic Algorithm Progress", gaProblem.getDisplay());  	GASolver solver = new GASolver(gaProblem, terminator, true);  	  	// try to set rest of properties...  	try  	{  		gaProblem.setMaxBlocks(((Integer)props.get(MAX_BLOCKS)).intValue());  		gaProblem.setScorePower(((Double)props.get(SCORE_POWER)).doubleValue());  		gaProblem.setPopulationSize(((Integer)props.get(POP_SIZE)).intValue());  		solver.setMutateProbability(((Double)props.get(MUTATE_PROB)).doubleValue());  		solver.setCloneProbability(((Double)props.get(CLONE_PROB)).doubleValue());  	} 		catch(Throwable t) 		{ 		  // ignore failures... 		}  	  	solver.start();  	terminator.setVisible(true); // center?  	  	// wait for it to finish...  	  	// get best model  	Blockmodel bestM = (Blockmodel)solver.getBestGene();  	return bestM; 	} 		public String[] getPropertyNames()	{		Enumeration keys = props.keys();		String[] names = new String[props.size()];		for(int ni=0; ni<names.length; ni++)		{			names[ni] = (String)keys.nextElement();		}		return names;	}		public Object getProperty(String name)	{		return props.get(name);	}		public void setProperty(String name, Object value)	{		// probably want to validate here		if(MAX_BLOCKS.equals(name) || POP_SIZE.equals(name) 		  || MAX_PRECISION.equals(name) || MIN_PRECISION.equals(name))		{			if(!(value instanceof Integer))			{				return;			}		}		else if(MUTATE_PROB.equals(name) || CLONE_PROB.equals(name)		  || SCORE_POWER.equals(name))		{			if(!(value instanceof Double))			{				return;			}		}		props.put(name, value);	}		public String toString()	{		return "Genetic Algorithm";	}}