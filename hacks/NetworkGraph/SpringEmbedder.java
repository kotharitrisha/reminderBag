/** * SpringEmbedder.java * * (c) 2000 Christopher Wheat */ package com.wibinet.networks;public class SpringEmbedder extends Thread{  protected VisualNetworkData nData;  protected long speed;  protected boolean alive;  protected double k; // spring constant  protected double beta; // damper  protected double friction; // friction  protected double baseLength = 1.0;   protected double normalLength = 120.0;    protected final static double VEL_K = 0.001;    // velocities  protected double[] xVel;  protected double[] yVel;    // data buffer  protected double[] nextXPos;  protected double[] nextYPos;    public SpringEmbedder(VisualNetworkData nData)  {    this.nData = nData;    speed = 100; // 10 cycles per second    alive = true;    k = 0.002;    beta = 0.2;    friction = 0.05;        nextXPos = new double[nData.xPos.length];    nextYPos = new double[nData.yPos.length];    xVel = new double[nData.xPos.length];    yVel = new double[nData.yPos.length];        reset();    alive = false; // don't start moving until unfrozen  }    public void setSpeed(double cyclesPerSec)  {    speed = (long)(((double)1000.0)/cyclesPerSec);  }    public void setConstant(double k)  {    this.k = k;  }    public void setDamper(double damper)  {    this.beta = damper;  }    public void start()  {    reset();    super.start();  }    public void reset()  {    for(int vi=0; vi<xVel.length; vi++)    {      xVel[vi] = 0.0;      yVel[vi] = 0.0;    }  }    public void run()  {    boolean keepRunning = true;    alive = false;    while(keepRunning)    {      if(alive)      {	      // run spring routine	      step();	    }      // sleep 'til next iteration      try      {        sleep(speed);      }      catch(InterruptedException ie)      {        keepRunning = false;      }    }  }    public void step()  {    calculateNextPositions();    copyData();  }    public void freeze()  {    alive = false;  }    public void unfreeze()  {    reset();    alive = true;  }    protected void calculateNextPositions()  {  	int relCt = nData.getRelationCount();    // for each position, calculate sum of forces...    for(int i1=0; i1<nextXPos.length; i1++)    {      double accX = 0.0;      double accY = 0.0;      for(int i2=0; i2<nextXPos.length; i2++)      {        if(i1 != i2) // ignore same forces        {          // find actual distance          double xDist = nData.getXPos(i2) - nData.getXPos(i1);          double yDist = nData.getYPos(i2) - nData.getYPos(i1);          double dist = Math.sqrt(xDist * xDist + yDist * yDist);                    // find 'rest length'          double totalTieStrength = 0;          for(int ri=0; ri<relCt; ri++)          {          	totalTieStrength += nData.getTieStrength(ri, i1, i2);          }          double restLength = normalLength / (baseLength + totalTieStrength);                    // find tension          double tension = dist-restLength;                    accX += (tension * (xDist/dist)) * k;          accY += (tension * (yDist/dist)) * k;        }      }            // calculate damping effect      accX -= beta * xVel[i1];      accY -= beta * yVel[i1];            // calculate next position      if(!nData.isNodeFrozen(i1))      {	      nextXPos[i1] = nData.getXPos(i1) + xVel[i1];	      nextYPos[i1] = nData.getYPos(i1) + yVel[i1];	      	      // calculate new velocities	      xVel[i1] += accX * speed * VEL_K;	      yVel[i1] += accY * speed * VEL_K;	    }	    else	    {	      nextXPos[i1] = nData.getXPos(i1);	      nextYPos[i1] = nData.getYPos(i1);	      xVel[i1] = 0.0;	      yVel[i1] = 0.0;	    }      // System.out.println("vel["+i1+"] = {"+xVel[i1]+", "+yVel[i1]+"}");      // System.out.println("acc["+i1+"] = {"+accX+", "+accY+"}");      // friction      /*      double accMag = Math.sqrt(accX * accX + accY * accY);      if(Math.abs(accMag) < friction)      {        xVel[i1] = 0.0;        yVel[i1] = 0.0;      }*/    }  }	protected void copyData()	{    // copy positions into data & redraw    nData.dataFreeze();    for(int mi=0; mi<nextXPos.length; mi++)    {      nData.xPos[mi] = nextXPos[mi];      nData.yPos[mi] = nextYPos[mi];    }    nData.unfreezeData();  }}